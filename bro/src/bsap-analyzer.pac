# Generated by binpac_quickstart

%header{
	RecordVal* HeaderToRecord($type{BSAP_Header} head, bool expanded);
	RecordVal* GlobalToRecord($type{BSAP_GlobalHeader} glbl);
	RecordVal* FuncToRecord($type{BSAP_FunctionHeader} func, $type{BSAP_FunctionCode} code);
	StringVal* FunctionCodeToString($type{BSAP_FunctionCode} code);
	RecordVal* NSBToRecord($type{BSAP_NodeStatus} nsb);
	RecordVal* DataHeadToRecord($type{BSAP_DataHeader} data);
%}

%code{
	RecordVal* HeaderToRecord($type{BSAP_Header} head, bool expanded) {
		DBG_LOG(DBG_PLUGINS, "startedHeaderCreation");

		RecordVal* converted = new RecordVal(BifType::Record::BSAP::Header);

		/*  if (expanded) { */
		/*  	converted->Assign(0,new Val(${head.exp},TYPE_COUNT)); */
		/* } */
		DBG_LOG(DBG_PLUGINS, "startedAssign");

		converted->Assign(1,new Val(${head.LADD},TYPE_COUNT));
		converted->Assign(2,new Val(${head.SER},TYPE_COUNT));
		/*converted->Assign(2,new Val(${head.DFUN}, TYPE_COUNT));*/

		if (${head.DADD} & 0x80) {
			converted->Assign(3,GlobalToRecord(${head.glbl}));
		}
		DBG_LOG(DBG_PLUGINS, "startedAssignFunc");

		converted->Assign(4,FunctionCodeToString(${head.DFUN}));
		DBG_LOG(DBG_PLUGINS, "startedAssignFuncToRec");

		converted->Assign(5,FuncToRecord(${head.func}, ${head.DFUN}));
		DBG_LOG(DBG_PLUGINS, "ReturningConverted");
		return converted;
	}

	RecordVal* GlobalToRecord($type{BSAP_GlobalHeader} glbl) {
		RecordVal* converted = new RecordVal(BifType::Record::BSAP::GlobalHeader);

		converted->Assign(1,new Val(${glbl.DADD},TYPE_COUNT));
		converted->Assign(2,new Val(${glbl.SADD},TYPE_COUNT));
		converted->Assign(3,new Val(${glbl.CTL},TYPE_COUNT));

		return converted;
	}

	RecordVal* FuncToRecord($type{BSAP_FunctionHeader} func, $type{BSAP_FunctionCode} code) {
		RecordVal* converted = new RecordVal(BifType::Record::BSAP::FunctionHeader);
		DBG_LOG(DBG_PLUGINS, "ShowNSB");
		//		DBG_LOG(DBG_PLUGINS, "NSB%d", ${func.NSB.Comm_Failure});
		if (code != ${FUNC_POLL})
			converted->Assign(1,NSBToRecord(${func.NSB}));
		else
			converted->Assign(0,new Val(${func.PRI},TYPE_COUNT));

		switch(${code}) {
			case ${FUNC_DOWN_ACK}:
			case ${FUNC_DIAL_UP_ACK}:
			case ${FUNC_NOD}:
			case ${FUNC_NACK}:
				converted->Assign(2, new Val(${func.SLV}, TYPE_COUNT));
				break;
			case ${FUNC_UP_ACK}:
				converted->Assign(3, new Val(${func.SERS}, TYPE_COUNT));
				break;
			case ${FUNC_POLL}:
				break; //no added fields
			default: //data messages
				converted->Assign(4, DataHeadToRecord(${func.data}));
				break;
		}
		return converted;
	}

	RecordVal* DataHeadToRecord($type{BSAP_DataHeader} data) {
		DBG_LOG(DBG_PLUGINS, "started Data Header Converter");
		RecordVal* converted = new RecordVal(BifType::Record::BSAP::DataHeader);
		converted->Assign(0, new Val(${data.SEQ}, TYPE_COUNT));
		converted->Assign(1, new Val(${data.SFUN}, TYPE_COUNT));
		return converted;

	}

	StringVal* FunctionCodeToString($type{BSAP_FunctionCode} code) {
		DBG_LOG(DBG_PLUGINS, "startedFuncToString");
		switch (${code}) {
			case ${FUNC_DIAL_UP_ACK}:
				return new StringVal("DU-Ack");
			case ${FUNC_POLL}:
				DBG_LOG(DBG_PLUGINS, "HitPOLLcase");
				return new StringVal("Poll");
			case ${FUNC_DOWN_ACK}:
				return new StringVal("Ack");
			case ${FUNC_NOD}:
				return new StringVal("Ack-NOD");
			case ${FUNC_UP_ACK}:
				return new StringVal("Up Ack");
			case ${FUNC_NACK}:
				return new StringVal("NAK");
			case ${FUNC_RDB}:
				return new StringVal("RDB");
			case ${FUNC_RDB_EXTENSION}:
				return new StringVal("E-RDB");
			default:
				DBG_LOG(DBG_PLUGINS, "HitDEFAULTcase");
				return new StringVal("Generic Data");
		}
	}

	RecordVal* NSBToRecord($type{BSAP_NodeStatus} nsb) {
		RecordVal* converted = new RecordVal(BifType::Record::BSAP::NodeStatus);
		DBG_LOG(DBG_PLUGINS, "StartNSBtoRecord");

		converted->Assign(0,new Val(${nsb.Alarms}, TYPE_BOOL));
		converted->Assign(1,new Val(${nsb.Input_Change}, TYPE_BOOL));
		converted->Assign(2,new Val(${nsb.Data_Pending}, TYPE_BOOL));
		converted->Assign(3,new Val(${nsb.Power_Failure}, TYPE_BOOL));
		converted->Assign(4,new Val(${nsb.Downloading}, TYPE_BOOL));
		converted->Assign(5,new Val(${nsb.VSAT_Message}, TYPE_BOOL));
		converted->Assign(6,new Val(${nsb.Exchange_Not_Found}, TYPE_BOOL));
		converted->Assign(7,new Val(${nsb.Comm_Failure}, TYPE_BOOL));

		return converted;
	}
%}

refine flow BSAP_Flow += {
	function proc_bsap_message(msg: BSAP_PDU): bool
	%{
		DBG_LOG(DBG_PLUGINS, "MessageToBeSent!Part1");
		
		DBG_LOG(DBG_PLUGINS, "byteStringParse");
                bytestring data = bytestring(${msg.rawData}.begin(),${msg.rawData}.end()-2);

                DBG_LOG(DBG_PLUGINS, c_str(data));



		RecordVal* header = HeaderToRecord(${msg.head},${msg.DleStx}[1] == 1);
		DBG_LOG(DBG_PLUGINS, "headerCreated!");

		//BifEvent::generate_bsap_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header, bytestring_to_val(data));
		DBG_LOG(DBG_PLUGINS, "EventGenerated!");
		


		switch (${msg.head.DFUN}) {
                        case ${FUNC_DIAL_UP_ACK}:
				//BifEvent::generate_bsap_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header,bytestring_to_val(data));
                                DBG_LOG(DBG_PLUGINS, "DU-Ack_gen");
				break;
                        case ${FUNC_POLL}:
				BifEvent::generate_poll_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header);
                                DBG_LOG(DBG_PLUGINS, "Poll_gen");
				break;
                        case ${FUNC_DOWN_ACK}:
				BifEvent::generate_ack_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header, data[0] );
                                DBG_LOG(DBG_PLUGINS, "Ack_gen");
				break;
                        case ${FUNC_NOD}:
				BifEvent::generate_ackNoData_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header, data[0] );
                                DBG_LOG(DBG_PLUGINS, "Ack-NOD_gen");
				break;
                        case ${FUNC_UP_ACK}:
				BifEvent::generate_upAck_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header);
                                DBG_LOG(DBG_PLUGINS, "Up Ack_gen");
				break;
                        case ${FUNC_NACK}:
				BifEvent::generate_nak_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header, data[0]);
                                DBG_LOG(DBG_PLUGINS, "NAK_gen");
				break;
                        case ${FUNC_RDB}:
			default:
				BifEvent::generate_dataMessage_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),header,bytestring_to_val(data));
                                DBG_LOG(DBG_PLUGINS, "default_dataMes_gen");
                        }



		return true;
	%}
};

refine typeattr BSAP_PDU += &let {
	proc: bool = $context.flow.proc_bsap_message(this);
};
